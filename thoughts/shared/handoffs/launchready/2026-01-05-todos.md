# LaunchReady Implementation Todos

**Date:** January 5, 2026  
**Updated:** January 5, 2026  
**Priority:** HIGH items first

---

## ‚úÖ COMPLETED (Full Feature List)

### Completed Prior to Jan 5
| Task | Status | Files |
|------|--------|-------|
| GitHub OAuth | ‚úÖ Done | `/api/auth/github/*` |
| Vercel OAuth | ‚úÖ Done | `/api/auth/vercel/*` |
| GitHub Tier 2 Scanning | ‚úÖ Done | `lib/github-scanner.ts` - secrets, debug code, deps |
| PDF Export | ‚úÖ Done | `/api/projects/[id]/export-pdf/route.tsx`, `lib/pdf-template.tsx` |

### Completed Jan 5, 2026
| Task | Status | Files Created/Modified |
|------|--------|----------------------|
| 1. Playwright E2E Tests | ‚úÖ Done | `playwright.config.ts`, `e2e/anonymous-scan.spec.ts` |
| 2. Auto-scan Scheduling | ‚úÖ Done | `vercel.json`, `/api/cron/auto-scan/route.ts` |
| 3. Settings Page | ‚úÖ Done | `/app/settings/page.tsx`, `/api/settings/route.ts` |
| 4. SSE Progress UI | ‚úÖ Done | `lib/hooks/useScanProgress.ts`, `components/ui/ScanProgressIndicator.tsx` |
| 5. Email Notifications | ‚úÖ Done | `lib/email.ts`, `/api/cron/weekly-digest/route.ts` |

### Run Tests
```bash
npm run test:e2e           # Run all E2E tests
npm run test:e2e:headed    # Run with browser visible
npm run test:e2e:ui        # Open Playwright UI
```

### Environment Variables Needed
```env
# Resend (email)
RESEND_API_KEY=re_xxxxx
EMAIL_FROM=LaunchReady <notifications@launchready.me>

# Cron secret (for production)
CRON_SECRET=your-secret-here
```

---

## üìã Table of Contents

1. [Fix Playwright E2E Tests](#1-fix-playwright-e2e-tests)
2. [Auto-scan Scheduling](#2-auto-scan-scheduling)
3. [Settings Page](#3-settings-page)
4. [Real-time SSE Progress UI](#4-real-time-sse-progress-ui)
5. [Email Notifications (Resend)](#5-email-notifications-resend)
6. [GitHub Integration](#6-github-integration)
7. [PDF Export](#7-pdf-export)

---

## 1. Fix Playwright E2E Tests

**Priority:** HIGH  
**Estimated Time:** 2-3 hours  
**Impact:** Quality assurance, CI/CD

### Problem

The anonymous scan form has React state sync issues when tested via browser automation. The "Scan Now" button click doesn't trigger the scan because the URL input value isn't being captured by React state.

### Root Cause Analysis

Looking at `app/page.tsx`:

```tsx
// Current implementation uses controlled input
const [url, setUrl] = useState('');

<input
  type="text"
  value={url}
  onChange={(e) => setUrl(e.target.value)}
  placeholder="yourproject.com"
/>
```

Browser automation tools type characters but React's controlled input may not fire `onChange` events properly.

### Solution

#### Option A: Add `name` attribute and use form data

```tsx
// In app/page.tsx - modify the form handling
async function handleScan(e: React.FormEvent<HTMLFormElement>) {
  e.preventDefault();
  const formData = new FormData(e.currentTarget);
  const urlValue = formData.get('url') as string;
  
  if (!urlValue?.trim()) {
    setError('URL is required');
    return;
  }
  
  // Use urlValue instead of url state
  setScanning(true);
  // ... rest of implementation
}

// Update input
<input
  type="text"
  name="url"  // Add name attribute
  value={url}
  onChange={(e) => setUrl(e.target.value)}
  placeholder="yourproject.com"
/>
```

#### Option B: Update Playwright config and tests

Create `playwright.config.ts`:

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: process.env.TEST_BASE_URL || 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 13'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
});
```

### New E2E Test File

Create `e2e/anonymous-scan.spec.ts`:

```typescript
// e2e/anonymous-scan.spec.ts
import { test, expect } from '@playwright/test';

const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:3000';

test.describe('Anonymous Scanning', () => {
  test('landing page loads with scan form', async ({ page }) => {
    await page.goto(BASE_URL);
    
    // Verify hero section
    await expect(page.locator('h1')).toContainText('Ready to Launch');
    
    // Verify scan form exists
    await expect(page.locator('input[placeholder*="project"]')).toBeVisible();
    await expect(page.locator('button:has-text("Scan")')).toBeVisible();
  });

  test('shows validation error for empty URL', async ({ page }) => {
    await page.goto(BASE_URL);
    
    // Click scan without entering URL
    await page.click('button:has-text("Scan")');
    
    // Should show validation error
    await expect(page.locator('text=URL is required')).toBeVisible();
  });

  test('can scan a valid URL', async ({ page }) => {
    await page.goto(BASE_URL);
    
    // Find the input - use more specific selector
    const input = page.locator('input[placeholder*="project"]');
    
    // Clear any existing value and type slowly
    await input.clear();
    await input.fill('https://example.com');
    
    // Verify the value is set
    await expect(input).toHaveValue('https://example.com');
    
    // Click the scan button
    await page.click('button:has-text("Scan")');
    
    // Wait for scanning state or navigation
    await expect(
      page.locator('text=/Scanning|Analyzing|Score/')
    ).toBeVisible({ timeout: 60000 });
  });

  test('scan completes and shows results', async ({ page }) => {
    await page.goto(BASE_URL);
    
    // Fill URL
    await page.locator('input[placeholder*="project"]').fill('https://google.com');
    
    // Submit
    await page.click('button:has-text("Scan")');
    
    // Wait for redirect to results page OR results to appear
    await page.waitForURL(/results/, { timeout: 90000 });
    
    // Verify results page content
    await expect(page.locator('text=/\\d+.*\\/.*100/')).toBeVisible();
    await expect(page.locator('text=/Domain|SEO|Performance|Security/')).toBeVisible();
  });

  test('shows CTA for non-logged-in users', async ({ page }) => {
    await page.goto(BASE_URL);
    
    await page.locator('input[placeholder*="project"]').fill('https://example.com');
    await page.click('button:has-text("Scan")');
    
    // Wait for results
    await page.waitForURL(/results/, { timeout: 90000 });
    
    // Should show CTA to create account
    await expect(
      page.locator('text=/Create.*account|Sign.*up|Save.*results/')
    ).toBeVisible();
  });
});

test.describe('Dashboard Access', () => {
  test('redirects to sign-in when not authenticated', async ({ page }) => {
    await page.goto(`${BASE_URL}/dashboard`);
    
    // Should redirect to sign-in
    await expect(page).toHaveURL(/sign-in/);
  });
});

test.describe('Pricing Page', () => {
  test('displays all pricing tiers', async ({ page }) => {
    await page.goto(`${BASE_URL}/pricing`);
    
    // Verify all tiers
    await expect(page.locator('text=Free')).toBeVisible();
    await expect(page.locator('text=Pro')).toBeVisible();
    await expect(page.locator('text=Pro Plus')).toBeVisible();
    await expect(page.locator('text=Enterprise')).toBeVisible();
    
    // Verify prices
    await expect(page.locator('text=$0')).toBeVisible();
    await expect(page.locator('text=$19')).toBeVisible();
    await expect(page.locator('text=$39')).toBeVisible();
    await expect(page.locator('text=$99')).toBeVisible();
  });

  test('highlights Pro as most popular', async ({ page }) => {
    await page.goto(`${BASE_URL}/pricing`);
    
    await expect(page.locator('text=Most Popular')).toBeVisible();
  });
});
```

### Running Tests

```bash
# Install Playwright browsers (one-time)
npx playwright install

# Run all E2E tests
npm run test:e2e

# Run with UI
npx playwright test --ui

# Run specific test file
npx playwright test e2e/anonymous-scan.spec.ts

# Debug mode
npx playwright test --debug

# Generate HTML report
npx playwright show-report
```

### Add Missing Dev Dependencies

```bash
npm install -D @playwright/test
```

### Update package.json Scripts

```json
{
  "scripts": {
    "test:e2e": "playwright test",
    "test:e2e:headed": "playwright test --headed",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:debug": "playwright test --debug"
  }
}
```

### Verification Checklist

- [ ] Create `playwright.config.ts`
- [ ] Update `app/page.tsx` form handling
- [ ] Create `e2e/anonymous-scan.spec.ts`
- [ ] Install `@playwright/test` dev dependency
- [ ] Run `npx playwright install` for browsers
- [ ] Verify all tests pass locally
- [ ] Run `npx playwright show-report` to see results

---

## 2. Auto-scan Scheduling

**Priority:** HIGH  
**Estimated Time:** 4-6 hours  
**Impact:** Core Pro feature, recurring revenue

### Spec Reference

From `2025-12-31-launchready-spec.md` ¬ß2:

> Pro Tier: Auto-Scan (Optional Daily Scheduling)
> - User toggles "Enable daily auto-scans" on project settings
> - System schedules cron job for project
> - Every day at user's preferred time (default: 6am UTC)
> - Email results if score dropped >5 points

### Database Schema (Already Exists)

```prisma
model Project {
  autoScanEnabled   Boolean   @default(false)
  autoScanSchedule  String?   // "daily-6am", "daily-12pm", "weekly-mon"
}
```

### Implementation Steps

#### Step 1: Create Cron Job Endpoint

Create `app/api/cron/auto-scan/route.ts`:

```typescript
// app/api/cron/auto-scan/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { addScanJob } from '@/lib/scan-queue';

// Vercel Cron or external cron service calls this endpoint
export async function GET(request: NextRequest) {
  // Verify cron secret (set in Vercel)
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const now = new Date();
  const currentHour = now.getUTCHours();
  
  // Determine which schedules to run
  const schedulesToRun = getSchedulesToRun(currentHour);
  
  console.log(`[Auto-scan] Running for schedules: ${schedulesToRun.join(', ')}`);

  // Find all projects with auto-scan enabled and matching schedule
  const projects = await prisma.project.findMany({
    where: {
      autoScanEnabled: true,
      autoScanSchedule: { in: schedulesToRun },
      user: {
        plan: { in: ['pro', 'pro_plus', 'enterprise'] },
      },
    },
    include: {
      user: true,
    },
  });

  console.log(`[Auto-scan] Found ${projects.length} projects to scan`);

  const results = [];
  
  for (const project of projects) {
    try {
      const job = await addScanJob({
        projectId: project.id,
        url: project.url,
        userId: project.userId,
        trigger: 'auto-scan',
      });
      
      results.push({
        projectId: project.id,
        projectName: project.name,
        jobId: job.id,
        status: 'queued',
      });
    } catch (error) {
      console.error(`[Auto-scan] Failed to queue ${project.name}:`, error);
      results.push({
        projectId: project.id,
        projectName: project.name,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }

  return NextResponse.json({
    processed: projects.length,
    results,
    timestamp: now.toISOString(),
  });
}

function getSchedulesToRun(hour: number): string[] {
  const schedules: string[] = [];
  
  // Daily schedules
  if (hour === 6) schedules.push('daily-6am');
  if (hour === 12) schedules.push('daily-12pm');
  if (hour === 18) schedules.push('daily-6pm');
  
  // Weekly schedules (Monday only)
  const dayOfWeek = new Date().getUTCDay();
  if (dayOfWeek === 1 && hour === 6) {
    schedules.push('weekly-mon');
  }
  
  return schedules;
}
```

#### Step 2: Configure Vercel Cron

Create `vercel.json` (or update if exists):

```json
{
  "crons": [
    {
      "path": "/api/cron/auto-scan",
      "schedule": "0 6,12,18 * * *"
    }
  ]
}
```

#### Step 3: Add Score Drop Detection

Update `lib/scan-queue.ts` to detect score drops:

```typescript
// Add to scan-queue.ts after scan completes

async function checkScoreDropAndNotify(projectId: string, userId: string) {
  const project = await prisma.project.findUnique({
    where: { id: projectId },
    include: {
      scans: {
        orderBy: { scannedAt: 'desc' },
        take: 2,
      },
      user: true,
    },
  });

  if (!project || project.scans.length < 2) return;

  const [current, previous] = project.scans;
  const scoreDrop = previous.score - current.score;

  if (scoreDrop > 5) {
    // Queue email notification (see Section 5)
    await sendScoreDropEmail({
      to: project.user.email,
      projectName: project.name,
      previousScore: previous.score,
      currentScore: current.score,
      dropAmount: scoreDrop,
      dashboardUrl: `${process.env.NEXT_PUBLIC_APP_URL}/projects/${project.id}`,
    });
  }
}
```

#### Step 4: Add Auto-scan Toggle to Dashboard

Update `app/dashboard/DashboardClient.tsx`:

```tsx
// Add to project card or detail view
<div className="flex items-center gap-2">
  <label className="text-sm text-slate-400">Auto-scan:</label>
  <select
    value={project.autoScanSchedule || 'disabled'}
    onChange={(e) => handleAutoScanChange(project.id, e.target.value)}
    disabled={userPlan === 'free'}
    className="bg-slate-700 text-white rounded px-2 py-1 text-sm"
  >
    <option value="disabled">Disabled</option>
    <option value="daily-6am">Daily (6am UTC)</option>
    <option value="daily-12pm">Daily (12pm UTC)</option>
    <option value="daily-6pm">Daily (6pm UTC)</option>
    <option value="weekly-mon">Weekly (Monday)</option>
  </select>
  {userPlan === 'free' && (
    <span className="text-xs text-amber-400">Pro feature</span>
  )}
</div>

// Add handler
async function handleAutoScanChange(projectId: string, schedule: string) {
  const enabled = schedule !== 'disabled';
  
  await fetch(`/api/projects/${projectId}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      autoScanEnabled: enabled,
      autoScanSchedule: enabled ? schedule : null,
    }),
  });
  
  // Refresh projects
  fetchProjects();
  
  toast({
    title: enabled ? 'Auto-scan enabled' : 'Auto-scan disabled',
    description: enabled 
      ? `Project will be scanned ${schedule.replace('-', ' at ')}`
      : 'Manual scans only',
  });
}
```

#### Step 5: Update Project API to Support PATCH

Update `app/api/projects/[id]/route.ts`:

```typescript
// Add PATCH method
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { userId } = await auth();
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;
  const body = await request.json();
  
  // Verify ownership
  const project = await prisma.project.findFirst({
    where: { id, user: { clerkId: userId } },
    include: { user: true },
  });

  if (!project) {
    return NextResponse.json({ error: 'Project not found' }, { status: 404 });
  }

  // Check if auto-scan is a paid feature
  if (body.autoScanEnabled && project.user.plan === 'free') {
    return NextResponse.json(
      { error: 'Auto-scan requires Pro plan', upgrade: true },
      { status: 403 }
    );
  }

  // Update project
  const updated = await prisma.project.update({
    where: { id },
    data: {
      ...(body.name && { name: body.name }),
      ...(body.url && { url: body.url }),
      ...(typeof body.autoScanEnabled === 'boolean' && { 
        autoScanEnabled: body.autoScanEnabled 
      }),
      ...(body.autoScanSchedule !== undefined && { 
        autoScanSchedule: body.autoScanSchedule 
      }),
      ...(body.githubRepo !== undefined && { githubRepo: body.githubRepo }),
    },
  });

  return NextResponse.json({ project: updated });
}
```

### Environment Variables

```bash
# Add to .env.local and Vercel
CRON_SECRET=your-secure-random-string
```

### Verification Checklist

- [ ] Create `app/api/cron/auto-scan/route.ts`
- [ ] Create/update `vercel.json` with cron config
- [ ] Add PATCH method to `app/api/projects/[id]/route.ts`
- [ ] Add auto-scan toggle UI to dashboard
- [ ] Add score drop detection to scan completion
- [ ] Set `CRON_SECRET` in Vercel environment
- [ ] Test cron endpoint manually: `curl -H "Authorization: Bearer $CRON_SECRET" https://launchready.me/api/cron/auto-scan`
- [ ] Verify Vercel cron shows in dashboard

---

## 3. Settings Page

**Priority:** HIGH  
**Estimated Time:** 3-4 hours  
**Impact:** User experience, integration management

### Spec Reference

From mockups ¬ß9 (Settings/Integrations Page):

> Settings page should allow users to:
> - Manage email preferences
> - Connect GitHub account
> - Configure webhooks (Pro Plus+)
> - View API keys (Enterprise)

### Implementation

#### Step 1: Create Settings Page

Create `app/settings/page.tsx`:

```tsx
// app/settings/page.tsx
import { currentUser } from '@clerk/nextjs/server';
import { redirect } from 'next/navigation';
import SettingsClient from './SettingsClient';

export default async function SettingsPage() {
  const user = await currentUser();
  
  if (!user) {
    redirect('/sign-in');
  }

  return <SettingsClient />;
}
```

Create `app/settings/SettingsClient.tsx`:

```tsx
// app/settings/SettingsClient.tsx
'use client';

import { useState, useEffect } from 'react';
import { useUser, UserButton } from '@clerk/nextjs';
import Link from 'next/link';
import {
  Rocket,
  Settings,
  Bell,
  Github,
  Webhook,
  Key,
  Mail,
  Check,
  AlertCircle,
  Loader2,
  ExternalLink,
} from 'lucide-react';

interface UserSettings {
  plan: string;
  emailNotifications: boolean;
  scoreDropAlerts: boolean;
  weeklyDigest: boolean;
  githubConnected: boolean;
  webhookUrl?: string;
}

export default function SettingsClient() {
  const { user, isLoaded } = useUser();
  const [settings, setSettings] = useState<UserSettings | null>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [toast, setToast] = useState<{ type: 'success' | 'error'; message: string } | null>(null);

  useEffect(() => {
    fetchSettings();
  }, []);

  async function fetchSettings() {
    try {
      const res = await fetch('/api/settings');
      if (res.ok) {
        const data = await res.json();
        setSettings(data);
      }
    } catch (error) {
      console.error('Failed to load settings:', error);
    } finally {
      setLoading(false);
    }
  }

  async function updateSettings(updates: Partial<UserSettings>) {
    setSaving(true);
    try {
      const res = await fetch('/api/settings', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      });

      if (res.ok) {
        const data = await res.json();
        setSettings(data);
        showToast('success', 'Settings saved');
      } else {
        showToast('error', 'Failed to save settings');
      }
    } catch (error) {
      showToast('error', 'Failed to save settings');
    } finally {
      setSaving(false);
    }
  }

  function showToast(type: 'success' | 'error', message: string) {
    setToast({ type, message });
    setTimeout(() => setToast(null), 3000);
  }

  if (!isLoaded || loading) {
    return (
      <div className="min-h-screen bg-slate-900 flex items-center justify-center">
        <Loader2 className="h-8 w-8 text-indigo-500 animate-spin" />
      </div>
    );
  }

  const isPro = settings?.plan && settings.plan !== 'free';
  const isProPlus = settings?.plan && ['pro_plus', 'enterprise'].includes(settings.plan);
  const isEnterprise = settings?.plan === 'enterprise';

  return (
    <div className="min-h-screen bg-slate-900 text-white">
      {/* Header */}
      <header className="border-b border-slate-800 bg-slate-900/80 backdrop-blur-sm sticky top-0 z-40">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center gap-4">
              <Link href="/dashboard" className="flex items-center gap-2">
                <Rocket className="h-6 w-6 text-indigo-500" />
                <span className="text-lg font-bold">LaunchReady.me</span>
              </Link>
              <span className="text-slate-600">|</span>
              <div className="flex items-center gap-2">
                <Settings className="h-5 w-5 text-slate-400" />
                <span className="text-slate-300">Settings</span>
              </div>
            </div>
            <UserButton afterSignOutUrl="/" />
          </div>
        </div>
      </header>

      {/* Toast */}
      {toast && (
        <div className={`fixed top-20 right-4 px-4 py-2 rounded-lg flex items-center gap-2 z-50 ${
          toast.type === 'success' ? 'bg-emerald-600' : 'bg-red-600'
        }`}>
          {toast.type === 'success' ? (
            <Check className="h-4 w-4" />
          ) : (
            <AlertCircle className="h-4 w-4" />
          )}
          {toast.message}
        </div>
      )}

      {/* Main Content */}
      <main className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Account Info */}
        <section className="mb-8">
          <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
            <Mail className="h-5 w-5" />
            Account
          </h2>
          <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-slate-300">{user?.emailAddresses[0]?.emailAddress}</p>
                <p className="text-sm text-slate-500">
                  Plan: <span className="text-indigo-400 font-medium capitalize">{settings?.plan || 'free'}</span>
                </p>
              </div>
              <Link
                href="/pricing"
                className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm font-medium transition-colors"
              >
                {isPro ? 'Manage Plan' : 'Upgrade'}
              </Link>
            </div>
          </div>
        </section>

        {/* Notifications */}
        <section className="mb-8">
          <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
            <Bell className="h-5 w-5" />
            Email Notifications
          </h2>
          <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-6 space-y-4">
            <ToggleItem
              label="Score drop alerts"
              description="Get notified when a project score drops by 5+ points"
              enabled={settings?.scoreDropAlerts ?? false}
              onChange={(v) => updateSettings({ scoreDropAlerts: v })}
              disabled={!isPro}
              proFeature={!isPro}
            />
            <ToggleItem
              label="Weekly digest"
              description="Receive a weekly summary of all your projects"
              enabled={settings?.weeklyDigest ?? false}
              onChange={(v) => updateSettings({ weeklyDigest: v })}
              disabled={!isPro}
              proFeature={!isPro}
            />
          </div>
        </section>

        {/* Integrations */}
        <section className="mb-8">
          <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
            <Github className="h-5 w-5" />
            Integrations
          </h2>
          <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-6 space-y-4">
            {/* GitHub */}
            <div className="flex items-center justify-between py-3 border-b border-slate-700/50">
              <div>
                <p className="font-medium flex items-center gap-2">
                  <Github className="h-4 w-4" />
                  GitHub
                </p>
                <p className="text-sm text-slate-400">
                  Connect to enable repository scanning
                </p>
              </div>
              {isPro ? (
                settings?.githubConnected ? (
                  <button
                    onClick={() => {/* TODO: Disconnect GitHub */}}
                    className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm"
                  >
                    Connected ‚úì
                  </button>
                ) : (
                  <button
                    onClick={() => {/* TODO: OAuth flow */}}
                    className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm"
                  >
                    Connect
                  </button>
                )
              ) : (
                <span className="text-sm text-amber-400">Pro feature</span>
              )}
            </div>

            {/* Webhooks */}
            <div className="py-3">
              <div className="flex items-center justify-between mb-3">
                <div>
                  <p className="font-medium flex items-center gap-2">
                    <Webhook className="h-4 w-4" />
                    Webhooks
                  </p>
                  <p className="text-sm text-slate-400">
                    Send scan results to Slack, Discord, or custom endpoint
                  </p>
                </div>
                {!isProPlus && (
                  <span className="text-sm text-amber-400">Pro Plus feature</span>
                )}
              </div>
              {isProPlus && (
                <input
                  type="url"
                  placeholder="https://your-webhook-url.com"
                  value={settings?.webhookUrl || ''}
                  onChange={(e) => updateSettings({ webhookUrl: e.target.value })}
                  className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-sm"
                />
              )}
            </div>
          </div>
        </section>

        {/* API Keys (Enterprise) */}
        {isEnterprise && (
          <section className="mb-8">
            <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
              <Key className="h-5 w-5" />
              API Access
            </h2>
            <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-6">
              <p className="text-slate-400 mb-4">
                Use the API to integrate LaunchReady with your systems.
              </p>
              <a
                href="/docs/api"
                className="text-indigo-400 hover:text-indigo-300 flex items-center gap-1"
              >
                View API Documentation <ExternalLink className="h-4 w-4" />
              </a>
            </div>
          </section>
        )}

        {/* Danger Zone */}
        <section>
          <h2 className="text-xl font-bold mb-4 text-red-400">Danger Zone</h2>
          <div className="bg-red-900/20 border border-red-800/50 rounded-xl p-6">
            <p className="text-slate-300 mb-4">
              Permanently delete your account and all data. This cannot be undone.
            </p>
            <button
              onClick={() => {/* TODO: Delete account flow */}}
              className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-sm"
            >
              Delete Account
            </button>
          </div>
        </section>
      </main>
    </div>
  );
}

function ToggleItem({
  label,
  description,
  enabled,
  onChange,
  disabled = false,
  proFeature = false,
}: {
  label: string;
  description: string;
  enabled: boolean;
  onChange: (value: boolean) => void;
  disabled?: boolean;
  proFeature?: boolean;
}) {
  return (
    <div className="flex items-center justify-between py-3 border-b border-slate-700/50 last:border-0">
      <div>
        <p className="font-medium">{label}</p>
        <p className="text-sm text-slate-400">{description}</p>
      </div>
      <div className="flex items-center gap-3">
        {proFeature && <span className="text-xs text-amber-400">Pro</span>}
        <button
          onClick={() => !disabled && onChange(!enabled)}
          disabled={disabled}
          className={`relative w-12 h-6 rounded-full transition-colors ${
            enabled ? 'bg-indigo-600' : 'bg-slate-700'
          } ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
        >
          <span
            className={`absolute top-1 left-1 w-4 h-4 bg-white rounded-full transition-transform ${
              enabled ? 'translate-x-6' : ''
            }`}
          />
        </button>
      </div>
    </div>
  );
}
```

#### Step 2: Create Settings API

Create `app/api/settings/route.ts`:

```typescript
// app/api/settings/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { prisma } from '@/lib/prisma';

export async function GET() {
  const { userId } = await auth();
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const user = await prisma.user.findUnique({
    where: { clerkId: userId },
    select: {
      plan: true,
      emailNotifications: true,
      scoreDropAlerts: true,
      weeklyDigest: true,
      githubConnected: true,
      webhookUrl: true,
    },
  });

  if (!user) {
    return NextResponse.json({ error: 'User not found' }, { status: 404 });
  }

  return NextResponse.json(user);
}

export async function PATCH(request: NextRequest) {
  const { userId } = await auth();
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();

  const user = await prisma.user.update({
    where: { clerkId: userId },
    data: {
      ...(typeof body.emailNotifications === 'boolean' && {
        emailNotifications: body.emailNotifications,
      }),
      ...(typeof body.scoreDropAlerts === 'boolean' && {
        scoreDropAlerts: body.scoreDropAlerts,
      }),
      ...(typeof body.weeklyDigest === 'boolean' && {
        weeklyDigest: body.weeklyDigest,
      }),
      ...(body.webhookUrl !== undefined && { webhookUrl: body.webhookUrl }),
    },
    select: {
      plan: true,
      emailNotifications: true,
      scoreDropAlerts: true,
      weeklyDigest: true,
      githubConnected: true,
      webhookUrl: true,
    },
  });

  return NextResponse.json(user);
}
```

#### Step 3: Update Prisma Schema

Add to `prisma/schema.prisma`:

```prisma
model User {
  // ... existing fields ...
  
  // Settings
  emailNotifications Boolean @default(true)
  scoreDropAlerts    Boolean @default(true)
  weeklyDigest       Boolean @default(false)
  githubConnected    Boolean @default(false)
  webhookUrl         String?
}
```

Run migration:

```bash
npx prisma migrate dev --name add_user_settings
```

#### Step 4: Add Settings Link to Dashboard

Update `app/dashboard/DashboardClient.tsx` header:

```tsx
// Add to navigation
<Link
  href="/settings"
  className="text-slate-400 hover:text-white transition-colors"
>
  <Settings className="h-5 w-5" />
</Link>
```

### Verification Checklist

- [ ] Create `app/settings/page.tsx` and `SettingsClient.tsx`
- [ ] Create `app/api/settings/route.ts`
- [ ] Update Prisma schema with settings fields
- [ ] Run database migration
- [ ] Add settings link to dashboard header
- [ ] Test toggle functionality
- [ ] Verify plan-based feature gating

---

## 4. Real-time SSE Progress UI

**Priority:** HIGH  
**Estimated Time:** 3-4 hours  
**Impact:** User experience during scans

### Current State

SSE backend is ready at `/api/queue/events`. Need to connect it to the dashboard UI.

### Implementation

#### Step 1: Create SSE Hook

Create `hooks/useScanProgress.ts`:

```typescript
// hooks/useScanProgress.ts
import { useState, useEffect, useCallback, useRef } from 'react';

interface JobUpdate {
  jobId: string;
  state: string;
  progress: number;
  projectName?: string;
  result?: any;
  error?: string;
}

interface UseScanProgressOptions {
  jobId?: string;
  watchAll?: boolean;
  onComplete?: (result: any) => void;
  onError?: (error: string) => void;
}

export function useScanProgress(options: UseScanProgressOptions = {}) {
  const { jobId, watchAll = false, onComplete, onError } = options;
  
  const [jobs, setJobs] = useState<Record<string, JobUpdate>>({});
  const [connected, setConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);

  const connect = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
    }

    let url = '/api/queue/events';
    const params = new URLSearchParams();
    if (jobId) params.set('jobId', jobId);
    if (watchAll) params.set('watchAll', 'true');
    if (params.toString()) url += `?${params.toString()}`;

    const eventSource = new EventSource(url);
    eventSourceRef.current = eventSource;

    eventSource.onopen = () => {
      setConnected(true);
      setError(null);
    };

    eventSource.onerror = () => {
      setConnected(false);
      setError('Connection lost. Retrying...');
    };

    eventSource.addEventListener('connected', (e) => {
      console.log('[SSE] Connected:', e.data);
    });

    eventSource.addEventListener('job-update', (e) => {
      const data: JobUpdate = JSON.parse(e.data);
      setJobs((prev) => ({
        ...prev,
        [data.jobId]: data,
      }));
    });

    eventSource.addEventListener('job-finished', (e) => {
      const data: JobUpdate = JSON.parse(e.data);
      setJobs((prev) => ({
        ...prev,
        [data.jobId]: data,
      }));
      
      if (data.state === 'completed' && onComplete) {
        onComplete(data.result);
      } else if (data.state === 'failed' && onError) {
        onError(data.error || 'Scan failed');
      }
    });

    eventSource.addEventListener('jobs-update', (e) => {
      const data: JobUpdate[] = JSON.parse(e.data);
      const jobsMap: Record<string, JobUpdate> = {};
      data.forEach((job) => {
        jobsMap[job.jobId] = job;
      });
      setJobs(jobsMap);
    });

    eventSource.addEventListener('idle', () => {
      setJobs({});
    });

    eventSource.addEventListener('timeout', () => {
      // Reconnect after timeout
      setTimeout(connect, 1000);
    });

    return () => {
      eventSource.close();
    };
  }, [jobId, watchAll, onComplete, onError]);

  useEffect(() => {
    const cleanup = connect();
    return cleanup;
  }, [connect]);

  const disconnect = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setConnected(false);
  }, []);

  const getJob = useCallback(
    (id: string) => jobs[id],
    [jobs]
  );

  return {
    jobs: Object.values(jobs),
    getJob,
    connected,
    error,
    reconnect: connect,
    disconnect,
  };
}
```

#### Step 2: Create Progress Component

Create `components/ui/ScanProgress.tsx`:

```tsx
// components/ui/ScanProgress.tsx
'use client';

import { Loader2, Check, AlertCircle, Clock } from 'lucide-react';

interface ScanProgressProps {
  jobId: string;
  projectName: string;
  state: string;
  progress: number;
  error?: string;
}

export function ScanProgress({
  jobId,
  projectName,
  state,
  progress,
  error,
}: ScanProgressProps) {
  const getStateIcon = () => {
    switch (state) {
      case 'active':
        return <Loader2 className="h-4 w-4 animate-spin text-indigo-400" />;
      case 'completed':
        return <Check className="h-4 w-4 text-emerald-400" />;
      case 'failed':
        return <AlertCircle className="h-4 w-4 text-red-400" />;
      default:
        return <Clock className="h-4 w-4 text-slate-400" />;
    }
  };

  const getStateText = () => {
    switch (state) {
      case 'waiting':
        return 'Waiting in queue...';
      case 'active':
        return `Scanning... ${progress}%`;
      case 'completed':
        return 'Completed!';
      case 'failed':
        return error || 'Failed';
      default:
        return state;
    }
  };

  return (
    <div className="bg-slate-800/50 border border-slate-700 rounded-lg p-4">
      <div className="flex items-center justify-between mb-2">
        <span className="font-medium text-white">{projectName}</span>
        <div className="flex items-center gap-2 text-sm">
          {getStateIcon()}
          <span className="text-slate-300">{getStateText()}</span>
        </div>
      </div>
      
      {state === 'active' && (
        <div className="w-full bg-slate-700 rounded-full h-2">
          <div
            className="bg-indigo-500 h-2 rounded-full transition-all duration-300"
            style={{ width: `${progress}%` }}
          />
        </div>
      )}
      
      {state === 'failed' && error && (
        <p className="text-sm text-red-400 mt-2">{error}</p>
      )}
    </div>
  );
}
```

#### Step 3: Add to Dashboard

Update `app/dashboard/DashboardClient.tsx`:

```tsx
// Add imports
import { useScanProgress } from '@/hooks/useScanProgress';
import { ScanProgress } from '@/components/ui/ScanProgress';

// Inside component
const { jobs, connected, error: sseError } = useScanProgress({
  watchAll: true,
  onComplete: () => {
    // Refresh projects when any scan completes
    fetchProjects();
  },
});

// Add to render, before projects list
{jobs.length > 0 && (
  <div className="mb-6">
    <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
      <span className="relative flex h-3 w-3">
        <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-indigo-400 opacity-75"></span>
        <span className="relative inline-flex rounded-full h-3 w-3 bg-indigo-500"></span>
      </span>
      Scans in Progress
    </h3>
    <div className="space-y-3">
      {jobs.map((job) => (
        <ScanProgress
          key={job.jobId}
          jobId={job.jobId}
          projectName={job.projectName || 'Unknown Project'}
          state={job.state}
          progress={job.progress}
          error={job.error}
        />
      ))}
    </div>
  </div>
)}

// Add "Scan All" button (Pro+ only)
{userPlan !== 'free' && projects.length > 1 && (
  <button
    onClick={handleScanAll}
    disabled={scanningAll}
    className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 disabled:bg-slate-700 rounded-lg text-sm font-medium flex items-center gap-2"
  >
    {scanningAll ? (
      <>
        <Loader2 className="h-4 w-4 animate-spin" />
        Queuing...
      </>
    ) : (
      <>
        <RefreshCw className="h-4 w-4" />
        Scan All Projects
      </>
    )}
  </button>
)}

// Add handler
const [scanningAll, setScanningAll] = useState(false);

async function handleScanAll() {
  setScanningAll(true);
  try {
    const res = await fetch('/api/queue/scan-all', { method: 'POST' });
    if (!res.ok) throw new Error('Failed to queue scans');
    
    const data = await res.json();
    toast({
      title: 'Scans queued',
      description: `${data.queued} projects will be scanned`,
    });
  } catch (error) {
    toast({
      title: 'Error',
      description: 'Failed to queue scans',
      variant: 'destructive',
    });
  } finally {
    setScanningAll(false);
  }
}
```

### Verification Checklist

- [ ] Create `hooks/useScanProgress.ts`
- [ ] Create `components/ui/ScanProgress.tsx`
- [ ] Update `DashboardClient.tsx` with SSE hook
- [ ] Add "Scan All" button for Pro+ users
- [ ] Test real-time updates during scan
- [ ] Verify auto-refresh on completion

---

## 5. Email Notifications (Resend)

**Priority:** HIGH  
**Estimated Time:** 3-4 hours  
**Impact:** User engagement, Pro feature

### Setup

1. Sign up at https://resend.com (free tier: 100 emails/day)
2. Verify domain or use onboarding domain
3. Get API key

### Implementation

#### Step 1: Install Resend

```bash
npm install resend
```

#### Step 2: Create Email Client

Create `lib/email.ts`:

```typescript
// lib/email.ts
import { Resend } from 'resend';

const resend = process.env.RESEND_API_KEY 
  ? new Resend(process.env.RESEND_API_KEY)
  : null;

const FROM_EMAIL = process.env.EMAIL_FROM || 'LaunchReady <noreply@launchready.me>';

interface EmailOptions {
  to: string;
  subject: string;
  html: string;
  text?: string;
}

export async function sendEmail(options: EmailOptions) {
  if (!resend) {
    console.log('[Email] Resend not configured, skipping email:', options.subject);
    return null;
  }

  try {
    const result = await resend.emails.send({
      from: FROM_EMAIL,
      ...options,
    });
    console.log('[Email] Sent:', options.subject, result.id);
    return result;
  } catch (error) {
    console.error('[Email] Failed:', error);
    throw error;
  }
}

// Email Templates

export async function sendScoreDropEmail({
  to,
  projectName,
  previousScore,
  currentScore,
  dropAmount,
  dashboardUrl,
}: {
  to: string;
  projectName: string;
  previousScore: number;
  currentScore: number;
  dropAmount: number;
  dashboardUrl: string;
}) {
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #4f46e5; color: white; padding: 20px; border-radius: 8px 8px 0 0; }
        .content { background: #f8fafc; padding: 20px; border-radius: 0 0 8px 8px; }
        .score { font-size: 48px; font-weight: bold; }
        .score-drop { color: #dc2626; }
        .button { display: inline-block; background: #4f46e5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin-top: 16px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>üö® Score Alert</h1>
        </div>
        <div class="content">
          <h2>${projectName}</h2>
          <p>Your project score has dropped:</p>
          <p class="score">
            <span style="color: #16a34a;">${previousScore}</span>
            ‚Üí
            <span class="score-drop">${currentScore}</span>
          </p>
          <p>That's a drop of <strong>${dropAmount} points</strong>.</p>
          <p>Common causes:</p>
          <ul>
            <li>SSL certificate expired or changed</li>
            <li>Performance degradation</li>
            <li>Missing meta tags</li>
            <li>Analytics removed</li>
          </ul>
          <a href="${dashboardUrl}" class="button">View Details ‚Üí</a>
          <p style="color: #64748b; font-size: 12px; margin-top: 24px;">
            You're receiving this because you have score drop alerts enabled.
            <a href="${process.env.NEXT_PUBLIC_APP_URL}/settings">Manage notifications</a>
          </p>
        </div>
      </div>
    </body>
    </html>
  `;

  return sendEmail({
    to,
    subject: `‚ö†Ô∏è ${projectName} score dropped ${dropAmount} points`,
    html,
    text: `Your project ${projectName} score dropped from ${previousScore} to ${currentScore}. View details: ${dashboardUrl}`,
  });
}

export async function sendWeeklyDigestEmail({
  to,
  userName,
  projects,
  dashboardUrl,
}: {
  to: string;
  userName: string;
  projects: Array<{
    name: string;
    score: number;
    change: number;
  }>;
  dashboardUrl: string;
}) {
  const projectRows = projects
    .map((p) => `
      <tr>
        <td style="padding: 8px; border-bottom: 1px solid #e2e8f0;">${p.name}</td>
        <td style="padding: 8px; border-bottom: 1px solid #e2e8f0; text-align: center;">${p.score}/100</td>
        <td style="padding: 8px; border-bottom: 1px solid #e2e8f0; text-align: center; color: ${p.change >= 0 ? '#16a34a' : '#dc2626'};">
          ${p.change >= 0 ? '+' : ''}${p.change}
        </td>
      </tr>
    `)
    .join('');

  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #4f46e5; color: white; padding: 20px; border-radius: 8px 8px 0 0; }
        .content { background: #f8fafc; padding: 20px; border-radius: 0 0 8px 8px; }
        table { width: 100%; border-collapse: collapse; }
        th { background: #e2e8f0; padding: 8px; text-align: left; }
        .button { display: inline-block; background: #4f46e5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin-top: 16px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>üìä Weekly Digest</h1>
        </div>
        <div class="content">
          <p>Hi ${userName},</p>
          <p>Here's your weekly summary:</p>
          <table>
            <thead>
              <tr>
                <th>Project</th>
                <th style="text-align: center;">Score</th>
                <th style="text-align: center;">Change</th>
              </tr>
            </thead>
            <tbody>
              ${projectRows}
            </tbody>
          </table>
          <a href="${dashboardUrl}" class="button">View Dashboard ‚Üí</a>
        </div>
      </div>
    </body>
    </html>
  `;

  return sendEmail({
    to,
    subject: 'üìä Your weekly LaunchReady digest',
    html,
  });
}

export async function sendWelcomeEmail({
  to,
  userName,
}: {
  to: string;
  userName: string;
}) {
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #4f46e5; color: white; padding: 20px; border-radius: 8px 8px 0 0; }
        .content { background: #f8fafc; padding: 20px; border-radius: 0 0 8px 8px; }
        .button { display: inline-block; background: #4f46e5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin-top: 16px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>üöÄ Welcome to LaunchReady!</h1>
        </div>
        <div class="content">
          <p>Hi ${userName},</p>
          <p>Thanks for signing up! Here's what you can do:</p>
          <ul>
            <li>‚úÖ Add your first project and get a readiness score</li>
            <li>üìä Track your progress over time</li>
            <li>üí° Get actionable recommendations</li>
          </ul>
          <p>Your free tier includes:</p>
          <ul>
            <li>1 project</li>
            <li>1 scan per day</li>
            <li>7 days of history</li>
          </ul>
          <a href="${process.env.NEXT_PUBLIC_APP_URL}/dashboard" class="button">Go to Dashboard ‚Üí</a>
          <p style="color: #64748b; font-size: 12px; margin-top: 24px;">
            Questions? Reply to this email or visit our docs.
          </p>
        </div>
      </div>
    </body>
    </html>
  `;

  return sendEmail({
    to,
    subject: 'üöÄ Welcome to LaunchReady!',
    html,
  });
}
```

#### Step 3: Integrate with Scan Completion

Update `lib/scan-queue.ts`:

```typescript
import { sendScoreDropEmail } from './email';

// In the job completion handler
scanQueue.on('completed', async (job, result) => {
  if (job.data.trigger === 'auto-scan') {
    await checkScoreDropAndNotify(job.data.projectId, job.data.userId);
  }
});

async function checkScoreDropAndNotify(projectId: string, userId: string) {
  const project = await prisma.project.findUnique({
    where: { id: projectId },
    include: {
      scans: {
        orderBy: { scannedAt: 'desc' },
        take: 2,
      },
      user: true,
    },
  });

  if (!project || project.scans.length < 2) return;
  if (!project.user.scoreDropAlerts) return; // Check user preference

  const [current, previous] = project.scans;
  const scoreDrop = previous.score - current.score;

  if (scoreDrop > 5) {
    await sendScoreDropEmail({
      to: project.user.email,
      projectName: project.name,
      previousScore: previous.score,
      currentScore: current.score,
      dropAmount: scoreDrop,
      dashboardUrl: `${process.env.NEXT_PUBLIC_APP_URL}/projects/${project.id}`,
    });
  }
}
```

#### Step 4: Create Weekly Digest Cron

Create `app/api/cron/weekly-digest/route.ts`:

```typescript
// app/api/cron/weekly-digest/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { sendWeeklyDigestEmail } from '@/lib/email';

export async function GET(request: NextRequest) {
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Get users with weekly digest enabled
  const users = await prisma.user.findMany({
    where: {
      weeklyDigest: true,
      plan: { not: 'free' }, // Only paid users
    },
    include: {
      projects: {
        include: {
          scans: {
            orderBy: { scannedAt: 'desc' },
            take: 2,
          },
        },
      },
    },
  });

  const results = [];

  for (const user of users) {
    if (user.projects.length === 0) continue;

    const projectSummaries = user.projects.map((p) => {
      const [current, previous] = p.scans;
      return {
        name: p.name,
        score: current?.score || 0,
        change: previous ? (current?.score || 0) - previous.score : 0,
      };
    });

    try {
      await sendWeeklyDigestEmail({
        to: user.email,
        userName: user.name || 'there',
        projects: projectSummaries,
        dashboardUrl: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard`,
      });
      results.push({ userId: user.id, status: 'sent' });
    } catch (error) {
      results.push({ userId: user.id, status: 'failed', error: String(error) });
    }
  }

  return NextResponse.json({ processed: users.length, results });
}
```

Add to `vercel.json`:

```json
{
  "crons": [
    {
      "path": "/api/cron/auto-scan",
      "schedule": "0 6,12,18 * * *"
    },
    {
      "path": "/api/cron/weekly-digest",
      "schedule": "0 9 * * 1"
    }
  ]
}
```

### Environment Variables

```bash
# Add to .env.local and Vercel
RESEND_API_KEY=re_...
EMAIL_FROM=LaunchReady <noreply@launchready.me>
NEXT_PUBLIC_APP_URL=https://launchready.me
```

### Verification Checklist

- [ ] Install `resend` package
- [ ] Create `lib/email.ts` with templates
- [ ] Integrate score drop detection with email
- [ ] Create weekly digest cron endpoint
- [ ] Update `vercel.json` with cron schedule
- [ ] Add `RESEND_API_KEY` to Vercel env
- [ ] Test emails in development (check Resend dashboard)

---

## 6. GitHub Integration

**Priority:** MEDIUM  
**Estimated Time:** 6-8 hours  
**Impact:** Tier 2 scanning capabilities

### Implementation Overview

1. Set up GitHub OAuth app
2. Create OAuth flow endpoints
3. Store GitHub tokens securely
4. Add repository scanning to scanner

### Files to Create

- `app/api/auth/github/route.ts` - OAuth initiation
- `app/api/auth/github/callback/route.ts` - OAuth callback
- `lib/github.ts` - GitHub API client
- Update `lib/scanner.ts` - Add repo scanning

### Spec Reference

From Spec ¬ß1 (Tier 2):

> Additional checks unlocked:
> - Secret scanning (leaked API keys)
> - Debug statements left in code
> - ENV variable parity
> - Dependency vulnerabilities

*Full implementation details available upon request*

---

## 7. PDF Export

**Priority:** MEDIUM  
**Estimated Time:** 4-5 hours  
**Impact:** Pro feature, sharing

### Implementation Overview

1. Install `@react-pdf/renderer` or use `puppeteer` for HTML-to-PDF
2. Create PDF template component
3. Add export endpoint
4. Add "Export PDF" button to project detail

### Spec Reference

From Spec ¬ß3 (Pro features):

> PDF exports
> - Share professional reports with clients, stakeholders
> - Custom branding (Pro Plus)

*Full implementation details available upon request*

---

## Summary Checklist

### Phase 1 (This Week)
- [ ] Fix Playwright E2E tests
- [ ] Implement auto-scan scheduling
- [ ] Create settings page
- [ ] Add real-time SSE progress UI
- [ ] Integrate Resend for emails

### Phase 2 (Next Week)
- [ ] GitHub integration
- [ ] PDF export

### Phase 3 (Future)
- [ ] Team members
- [ ] White-label reports
- [ ] API documentation
- [ ] Vercel integration

---

## Resources

- [Spec Document](/Users/miguel/Reboot/thoughts/shared/plans/2025-12-31-launchready-spec.md)
- [Mockups](/Users/miguel/Reboot/thoughts/shared/plans/2025-12-31-launchready-mockups.md)
- [Implementation Checklist](/Users/miguel/Reboot/thoughts/shared/plans/2025-12-31-launchready-implementation-checklist.md)
- [Playwright Docs](https://playwright.dev/docs/intro)
- [Resend Docs](https://resend.com/docs)
- [Vercel Cron Docs](https://vercel.com/docs/cron-jobs)
